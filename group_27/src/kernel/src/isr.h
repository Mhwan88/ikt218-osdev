//
// isr.h -- Interface and structures for high level interrupt service routines.
// Part of this code is modified from Bran's kernel development tutorials.
// Rewritten for JamesM's kernel development tutorials.
//

// Define the Interrupt Request numbers
#define IRQ0 32
#define IRQ1 33
#define IRQ2 34
#define IRQ3 35
#define IRQ4 36
#define IRQ5 37
#define IRQ6 38
#define IRQ7 39
#define IRQ8 40
#define IRQ9 41
#define IRQ10 42
#define IRQ11 43
#define IRQ12 44
#define IRQ13 45
#define IRQ14 46
#define IRQ15 47

typedef struct registers
{
   u32int ds;                  // Data segment selector
   u32int edi, esi, ebp, esp, ebx, edx, ecx, eax; // Pushed by pusha.
   u32int int_no, err_code;    // Interrupt number and error code (if applicable)
   u32int eip, cs, eflags, useresp, ss; // Pushed by the processor automatically.
} registers_t; 

extern "C" {
   extern void irq_handler(registers_t regs);
}

typedef void (*isr_t)(registers_t);
void register_interrupt_handler(u8int n, isr_t handler);

// Create an array of interrupt handlers
isr_t interrupt_handlers[256];

// Register the interrupt handlers
void register_interrupt_handler(u8int n, isr_t handler)
{
  interrupt_handlers[n] = handler;
} 

// For some rason just has to be here instead of in common.h
// Write a byte out to the specified port.
void outb(u16int port, u8int value)
{
    asm volatile ("outb %1, %0" : : "dN" (port), "a" (value));
}


// Gets called from the ASM interrupt handler in interrupt.asm
void irq_handler(registers_t regs)
{
   // Sends an EOI (end of interrupt) signal to the PICs.
   // If this interrupt involved the slave
   if (regs.int_no >= 40)
   {
       // Send reset signal to slave.
       outb(0xA0, 0x20);
   }
   // Send reset signal to master. (As well as slave, if necessary).
   outb(0x20, 0x20);

   if (interrupt_handlers[regs.int_no] != 0)
   {
       isr_t handler = interrupt_handlers[regs.int_no];
       handler(regs);
   }
} 
